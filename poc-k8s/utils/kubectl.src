#!/bin/echo "source me !"
# Requires: /../../dependencies/downloads/poc-bash-master/includes/print-utils.src
# 	    /../../dependencies/downloads/poc-bash-master/includes/trace-utils.src
#       /../../dependencies/downloads/poc-bash-master/includes/progress-bar-utils.src
#           /../../utils/microservices-utils.src

##########################
#  K8S GLOBAL VARIABLES  #
##########################
NAMESPACE=""
LABELS=""

##########################
#    BASIC K8S METHODS   #
##########################

function kubectl::showNodes() {
  print_info "Show information about nodes"
  xtrace on
  kubectl get nodes
  xtrace off
  checkInteractiveMode
}

function kubectl::getNodeAddresses() {
  xtrace on
  kubectl get nodes --no-headers \
    -o custom-columns=":status.addresses[?(@.type == 'InternalIP')].address"
  xtrace off
}

function kubectl::apply() {
  print_info "Apply configuration"
  xtrace on
  kubectl apply -f $1
  xtrace off
  sleep 1
  checkInteractiveMode
}

function kubectl::unapply() {
  print_info "Unapply configuration"
  xtrace on
  kubectl delete -f $1
  xtrace off
  sleep 3
}

function kubectl::showAll() {
  print_info "Show all objects by default namespace"
  xtrace on
  kubectl get all -l $1 -o wide
  xtrace off
  checkInteractiveMode
}

function kubectl::resetGlobalVariables() {
  NAMESPACE=""
  LABELS=""
}

function kubectl::manageArguments() {
  kubectl::resetGlobalVariables
  OPTIND=1
  while getopts "n:l:" option; do
    case ${option} in
      n) NAMESPACE=$OPTARG
         ;;
      l) LABELS=$OPTARG
         ;;
      ?) echo "Invalid option: $OPTARG" 1>&2
         ;;
      :) echo "Invalid option: $OPTARG requires an argument" 1>&2
    esac
  done
  shift $((OPTIND-1))
}

### PODS

function kubectl::showPods() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::showPodsInAllNamespaces() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl get pods --all-namespaces ${LABELS:+-l $LABELS} --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::getRunningPods() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get po --no-headers | grep Running | awk '{print $1}'
  xtrace off
}

function kubectl::getPodNames() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get pods --no-headers -o custom-columns=":metadata.name"
  xtrace off
}

function kubectl::getPodStatus() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get pods --no-headers -o custom-columns=":status.phase"
  xtrace off
}

function kubectl::getFirstPodName() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get pods -o jsonpath="{.items[0].metadata.name}"
  xtrace off
}

function kubectl::waitForPodsByLabel() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait pods -l $1 --for=condition=Ready
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait pods -l $1 --for=condition=Ready --timeout=30s
  xtrace off
}

function kubectl::deletePod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} delete pod $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogs() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogsByContainer() {
  pod=$1
  container=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod -c $container
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainer() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $@
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithTty() {
  pod=$1
  shift
  xtrace on
  kubectl exec -it $pod -- $@
  xtrace off
  checkInteractiveMode
}

### REPLICASETS

function kubectl::showReplicaSets() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showReplicaSetsInAllNamespaces() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  kubectl get rs --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromReplicaSet() {
  replicaSet=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs $replicaSet -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleReplicaSet() {
  replicaSet=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale replicaset $replicaSet --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

### DEPLOYMENTS

function kubectl::showDeployments() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showDeploymentsInAllNamespaces() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  kubectl get deploy --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromDeployment() {
  deploy=$1
  kubectl::manageArguments $@
  shift
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get deploy $deploy -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleDeployment() {
  deploy=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale deployment $deploy --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

function kubectl::waitForDeployment() {
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    wait --for=condition=available deployment $deploy
  xtrace off
}

function kubectl::showRolloutStatusFromDeployment() {
  print_info "Show rollout status from deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout status deployment $deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::rollbackDeployment() {
  print_info "Rollout undo deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout undo deployment $deploy
  xtrace off
  checkInteractiveMode
}

### SERVICES

function kubectl::showServices() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showServicesInAllNamespaces() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl get svc --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showEndpointsByService() {
  print_info "Show endpoints filtered by service"
  service=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get endpoints $service
  xtrace off
  checkInteractiveMode
}

function kubectl::getPortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].port"
  xtrace off
}

function kubectl::getNodePortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].nodePort"
  xtrace off
}
