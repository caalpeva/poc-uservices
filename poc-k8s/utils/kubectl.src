#!/bin/echo "source me !"
# Requires: /../../dependencies/downloads/poc-bash-master/includes/print-utils.src
# 	    /../../dependencies/downloads/poc-bash-master/includes/trace-utils.src
#       /../../dependencies/downloads/poc-bash-master/includes/progress-bar-utils.src
#           /../../utils/microservices-utils.src

##########################
#  K8S GLOBAL VARIABLES  #
##########################
NAMESPACE=""
LABELS=""

##########################
#    BASIC K8S METHODS   #
##########################

function kubectl::showKubeconfig() {
  print_info "Check the active kubeconfig"
  xtrace on
  echo "KUBECONFIG=$KUBECONFIG"
  kubectl config view
  xtrace off
  checkInteractiveMode
}

function kubectl::showKubeconfigFile() {
  xtrace on
  kubectl --kubeconfig=$1 config view
  xtrace off
  checkInteractiveMode
}

function kubectl::showNodes() {
  print_info "Show information about nodes"
  xtrace on
  kubectl get nodes
  xtrace off
  checkInteractiveMode
}

function kubectl::getNodeAddresses() {
  xtrace on
  kubectl get nodes --no-headers \
    -o custom-columns=":status.addresses[?(@.type == 'InternalIP')].address"
  xtrace off
}

function kubectl::apply() {
  print_info "Apply configuration"
  xtrace on
  kubectl apply -f $@
  xtrace off
  sleep 1
}

function kubectl::unapply() {
  print_info "Unapply configuration"
  xtrace on
  kubectl delete -f $@ --ignore-not-found=true
  xtrace off
  sleep 3
}

function kubectl::showAll() {
  print_info "Show all objects by default namespace"
  xtrace on
  kubectl get all -l $1 -o wide
  xtrace off
  checkInteractiveMode
}

function kubectl::resetGlobalVariables() {
  NAMESPACE=""
  LABELS=""
}

function kubectl::manageArguments() {
  kubectl::resetGlobalVariables
  OPTIND=1
  while getopts "n:l:" option; do
    case ${option} in
      n) NAMESPACE=$OPTARG
         ;;
      l) LABELS=$OPTARG
         ;;
      ?) echo "Invalid option: $OPTARG" 1>&2
         ;;
      :) echo "Invalid option: $OPTARG requires an argument" 1>&2
    esac
  done
  shift $((OPTIND-1))
}

##########################
#       POD METHODS      #
##########################

function kubectl::showPods() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::showPodsInAllNamespaces() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl get pods --all-namespaces ${LABELS:+-l $LABELS} --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::getRunningPods() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get po --no-headers | grep Running | awk '{print $1}'
  xtrace off
}

function kubectl::getPodNames() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get pods --no-headers -o custom-columns=":metadata.name"
  xtrace off
}

function kubectl::getPodStatus() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    --no-headers -o custom-columns=":status.phase"
  xtrace off
}

function kubectl::getFirstPodName() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    -o jsonpath="{.items[0].metadata.name}"
  xtrace off
}

function kubectl::waitForPodsByLabel() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    wait pods ${LABELS:+-l $LABELS} \
    --for=condition=Ready
    #--timeout=30s
  xtrace off
  checkInteractiveMode
}

function kubectl::deletePod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} delete pod $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::forceDeletePod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} delete pod $pod --force --grace-period=0
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogs() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogsByContainer() {
  pod=$1
  container=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod -c $container
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainer() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $*
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithReturnCarriage() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $*
  xtrace off
  echo
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithTty() {
  pod=$1
  shift
  xtrace on
  kubectl exec -it $pod -- $@
  xtrace off
  checkInteractiveMode
}

##########################
#   REPLICASET METHODS   #
##########################

function kubectl::showReplicaSets() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showReplicaSetsInAllNamespaces() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  kubectl get rs --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromReplicaSet() {
  replicaSet=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs $replicaSet -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleReplicaSet() {
  replicaSet=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale replicaset $replicaSet --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

##########################
#   DEPLOYMENT METHODS   #
##########################

function kubectl::showDeployments() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showDeploymentsInAllNamespaces() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  kubectl get deploy --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromDeployment() {
  deploy=$1
  kubectl::manageArguments $@
  shift
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get deploy $deploy -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleDeployment() {
  deploy=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale deployment $deploy --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

function kubectl::waitForDeployment() {
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    wait --for=condition=available deployment $deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::showRolloutStatusFromDeployment() {
  print_info "Show rollout status from deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout status deployment $deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::rollbackDeployment() {
  print_info "Rollout undo deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout undo deployment $deploy
  xtrace off
  checkInteractiveMode
}

##########################
#     SERVICE METHODS    #
##########################

function kubectl::showServices() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showServicesInAllNamespaces() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl get svc --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showEndpointsByService() {
  print_info "Show endpoints filtered by service"
  service=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get endpoints $service
  xtrace off
  checkInteractiveMode
}

function kubectl::getPortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].port"
  xtrace off
}

function kubectl::getNodePortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].nodePort"
  xtrace off
}

##########################
#   CONFIGMAP METHODS    #
##########################

function kubectl::showConfigMaps() {
  print_info "Show configmaps"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get cm ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showConfigMapDescription() {
  configmap=$1
  shift
  print_info "Show configmap description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe cm $configmap ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

##########################
#    SECRETS METHODS     #
##########################

function kubectl::createGenericSecret() {
  dstFile=$1
  shift
  secret=$1
  shift
  pocLabel=$1
  shift
  print_info "Create generic secret and edit labels"
  xtrace on
  kubectl create secret generic $secret $@ \
    --dry-run=client -o yaml | \
    sed -e 's|creationTimestamp: null|labels:|' | \
    sed -e "s/labels:/& \n    $pocLabel/" | \
    tee $dstFile | kubectl apply -f -
  xtrace off
  checkInteractiveMode
}

function kubectl::showSecrets() {
  print_info "Show secrets"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get secrets ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showSecretDescription() {
  secret=$1
  shift
  print_info "Show secret description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe secrets $secret ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::decodeSecretByKey() {
  secret=$1
  secretKey=$2
  shift
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get secret $secret \
    -o custom-columns=":data['${secretKey}']" | base64 --decode
  xtrace off
}

function kubectl::deleteSecret() {
  xtrace on
  kubectl delete secret $1
  xtrace off
  checkInteractiveMode
}
