#!/bin/echo "source me !"
# Requires: /../../dependencies/downloads/poc-bash-master/includes/print-utils.src
# 	    /../../dependencies/downloads/poc-bash-master/includes/trace-utils.src
#       /../../dependencies/downloads/poc-bash-master/includes/progress-bar-utils.src
#           /../../utils/microservices-utils.src

##########################
#    BASIC K8S METHODS   #
##########################

function kubectl::showNodes() {
  print_info "Show information about nodes"
  xtrace on
  kubectl get nodes
  xtrace off
  checkInteractiveMode
}

function kubectl::apply() {
  print_info "Apply configuration"
  xtrace on
  kubectl apply -f $1
  xtrace off
  sleep 1
  checkInteractiveMode
}

function kubectl::unapply() {
  print_info "Unapply configuration"
  xtrace on
  kubectl delete -f $1
  xtrace off
  sleep 3
}

function kubectl::showAll() {
  print_info "Show all objects by default namespace"
  xtrace on
  kubectl get all -l $1 -o wide
  xtrace off
  checkInteractiveMode
}

### PODS

function kubectl::showPods() {
  print_info "Show pods by default namespace"
  xtrace on
  kubectl get pods --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::showPodsByLabel() {
  print_info "Show pods by default namespace"
  xtrace on
  kubectl get pods -l $1 --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::showPodsByNamespace() {
  namespace=$1
  print_info "Show pods by namespace $namespace"
  xtrace on
  kubectl -n $namespace get po -o wide
  xtrace off
  checkInteractiveMode
}

function kubectl::getRunningPods() {
  xtrace on
  #-o=custom-columns=NAME:.metadata.name,S:.status.phase \
  kubectl get po --no-headers | grep Running | awk '{print $1}'
  xtrace off
}

function kubectl::getPodNames() {
  xtrace on
  kubectl get pods --no-headers -o custom-columns=":metadata.name"
  xtrace off
}

function kubectl::getPodStatus() {
  xtrace on
  kubectl get pods --no-headers -o custom-columns=":status.phase"
  xtrace off
}

function kubectl::getFirstPodName() {
  xtrace on
  kubectl get pods -o jsonpath="{.items[0].metadata.name}"
  xtrace off
}

function kubectl::getFirstPodNameByLabel() {
  xtrace on
  kubectl get pods -l $1 -o jsonpath="{.items[0].metadata.name}"
  xtrace off
}

function kubectl::waitForPodsByLabel() {
  xtrace on
  kubectl wait pods -l $1 --for=condition=Ready
  #kubectl wait pods -l $1 --for=condition=Ready --timeout=30s
  xtrace off
}

function kubectl::deletePod() {
  xtrace on
  kubectl delete pod $1
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogs() {
  pod=$1
  xtrace on
  kubectl wait --for=condition=ready pod $pod
  kubectl logs $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogsByContainer() {
  pod=$1
  container=$2
  xtrace on
  kubectl wait --for=condition=ready pod $pod
  kubectl logs $pod -c $container
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainer() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $@
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithTty() {
  pod=$1
  shift
  xtrace on
  kubectl exec -it $pod -- $@
  xtrace off
  checkInteractiveMode
}

### REPLICASETS

function kubectl::showReplicaSets() {
  print_info "Show replicasets by default namespace"
  xtrace on
  #kubectl get rs -o wide
  kubectl get rs
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromReplicaSet() {
  xtrace on
  kubectl get rs $1 -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleReplicaSet() {
  print_info "Scale replicas to $2"
  xtrace on
  kubectl scale replicaset $1 --replicas=$2
  xtrace off
  checkInteractiveMode
}

### DEPLOYMENTS

function kubectl::showDeployments() {
  print_info "Show deployments by default namespace"
  xtrace on
  #kubectl get deploy -o wide
  kubectl get deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromDeployment() {
  xtrace on
  kubectl get deploy $1 -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleDeployment() {
  print_info "Scale replicas to $2"
  xtrace on
  kubectl scale deployment $1 --replicas=$2
  xtrace off
  checkInteractiveMode
}

function kubectl::waitForDeployment() {
  xtrace on
  kubectl wait --for=condition=available deployment $1
  xtrace off
}

function kubectl::showRolloutStatusFromDeployment() {
  print_info "Show rollout status from deployment"
  xtrace on
  kubectl rollout status deployment $1
  xtrace off
  checkInteractiveMode
}

function kubectl::rollbackDeployment() {
  print_info "Rollout undo deployment"
  xtrace on
  kubectl rollout undo deployment $1
  xtrace off
  checkInteractiveMode
}

### SERVICES

function kubectl::showServices() {
  print_info "Show services by default namespace"
  xtrace on
  kubectl get svc -l $1
  xtrace off
  checkInteractiveMode
}

function kubectl::showEndpointsByService() {
  print_info "Show endpoints filtered by service"
  xtrace on
  kubectl get endpoints $1
  xtrace off
  checkInteractiveMode
}

function kubectl::execContainerPing() {
  from=$1
  to=$2
  command="docker exec $from ping $to -c 3"
  echo "+ $command"
  eval "$command"
  return $?
}

function kubectl::execContainerPingAsRoot() {
  from=$1
  to=$2
  command="docker exec -u root $from ping $to -c 3"
  echo "+ $command"
  eval "$command"
  return $?
}

function kubectl::checkUrl  {
  command="curl $1"
  echo "+ $command"
  eval "$command"
  return $?
}

function kubectl::checkHttpServerAvailability  {
  declare -i result=0
  print_info "Check that the Http server from $1 is available..."
  print_debug "Extract host port from container data..."
  port=$(docker::getFirstHostPortFromContainerData $1 $2)

  docker::checkUrl "http://localhost:${port}"
  if [ $? -ne 0 ]
  then
    print_error "Http server from $1 is not available"
    result=1
  fi

  checkInteractiveMode
  return $result
}
