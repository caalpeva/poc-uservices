#!/bin/echo "source me !"
# Requires:
# /../../dependencies/downloads/poc-bash-master/includes/print-utils.src
# /../../dependencies/downloads/poc-bash-master/includes/trace-utils.src
# /../../dependencies/downloads/poc-bash-master/includes/progress-bar-utils.src
# /../../utils/microservices-utils.src

##########################
#  K8S GLOBAL VARIABLES  #
##########################
NAMESPACE=""
LABELS=""

RESTART_TIMEOUT_SECS=300
RESTART_INTERVAL_SECS=25   # Set interval (duration) in seconds

METRICS_TIMEOUT_SECS=150  # Set timeout in seconds
METRICS_INTERVAL_SECS=10   # Set interval (duration) in seconds

##########################
#    BASIC K8S METHODS   #
##########################

function kubectl::showKubeconfig() {
  print_info "Check the active KUBECONFIG"
  xtrace on
  echo "KUBECONFIG=$KUBECONFIG"
  kubectl config view
  xtrace off
  checkInteractiveMode
}

function kubectl::showKubeconfigFile() {
  xtrace on
  kubectl --kubeconfig=$1 config view
  xtrace off
  checkInteractiveMode
}

function kubectl::setKubeconfig() {
  print_debug "Set KUBECONFIG to new kubeconfig file"
  kubeconfigFile=$1
  xtrace on
  export KUBECONFIG=$kubeconfigFile
  xtrace off
  checkInteractiveMode
}

function kubectl::unsetKubeconfig() {
  print_debug "Unset KUBECONFIG"
  xtrace on
  unset KUBECONFIG
  xtrace off
}

function kubectl::showNodes() {
  print_info "Show information about nodes"
  xtrace on
  kubectl get nodes
  xtrace off
  checkInteractiveMode
}

function kubectl::getNodeAddresses() {
  xtrace on
  kubectl get nodes --no-headers \
    -o custom-columns=":status.addresses[?(@.type == 'InternalIP')].address"
  xtrace off
}

function kubectl::apply() {
  print_info "Apply configuration"
  for file in $@
  do
    xtrace on
    kubectl apply -f $file
    xtrace off
  done
  sleep 1
}

function kubectl::applyWithRecord() {
  print_info "Apply configuration"
  for file in $@
  do
    xtrace on
    kubectl apply -f $file --record
    xtrace off
  done
  sleep 1
}

function kubectl::unapply() {
  print_info "Unapply configuration"
  for file in $@
  do
    xtrace on
    kubectl delete -f $file --wait=true --ignore-not-found=true
    xtrace off
  done
  sleep 3
}

function kubectl::showAll() {
  print_info "Show all objects by default namespace"
  xtrace on
  kubectl get all -l $1 -o wide
  xtrace off
  checkInteractiveMode
}

function kubectl::resetGlobalVariables() {
  NAMESPACE=""
  LABELS=""
}

function kubectl::manageArguments() {
  kubectl::resetGlobalVariables
  OPTIND=1
  while getopts "n:l:" option; do
    case ${option} in
      n) NAMESPACE=$OPTARG
         ;;
      l) LABELS=$OPTARG
         ;;
      ?) echo "Invalid option: $OPTARG" 1>&2
         ;;
      :) echo "Invalid option: $OPTARG requires an argument" 1>&2
    esac
  done
  shift $((OPTIND-1))
}

##########################
#       POD METHODS      #
##########################

function kubectl::showPods() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::showPodsInAllNamespaces() {
  print_info "Show pods"
  kubectl::manageArguments $@
  xtrace on
  kubectl get pods --all-namespaces ${LABELS:+-l $LABELS} --output wide
  xtrace off
  checkInteractiveMode
}

function kubectl::getRunningPods() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get po --no-headers | grep Running | awk '{print $1}'
  xtrace off
}

function kubectl::getAllPods() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get po --no-headers | awk '{print $1}'
  xtrace off
}

function kubectl::getPodNames() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get pods --no-headers -o custom-columns=":metadata.name"
  xtrace off
}

function kubectl::getPodStatus() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    --no-headers -o custom-columns=":status.phase"
  xtrace off
}

function kubectl::getRamLimitFromDeployment() {
  deployment=$1
  shift
  #kubectl get pods -o json
  #kubectl get pods -o=jsonpath='{@}'
  #kubectl get pods -o=jsonpath='{.items[0]}'
  #kubectl get pods -o=jsonpath='{.items[0].metadata.name}'
  #kubectl get pods -o=jsonpath="{.items[*]['metadata.name', 'status.capacity']}"
  #kubectl get pods -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.startTime}{"\n"}{end}'
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get deploy $deployment -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{..resources.limits.memory}{"\n"}'
  xtrace off
}

function kubectl::getCpuLimitFromDeployment() {
  deployment=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get deploy $deployment -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{..resources.limits.cpu}{"\n"}'
  xtrace off
}

function kubectl::getRestartCountByPod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pod $pod --no-headers \
    -o custom-columns=":status.containerStatuses[0].restartCount"
  xtrace off
}

function kubectl::getFirstPodName() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pods ${LABELS:+-l $LABELS} \
    -o jsonpath="{.items[0].metadata.name}"
  xtrace off
}

function kubectl::waitForPodsByLabel() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    wait pods ${LABELS:+-l $LABELS} \
    --for=condition=Ready
    #--timeout=30s
  xtrace off
  checkInteractiveMode
}

function kubectl::waitForReadyPod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  xtrace off
}


function kubectl::deletePod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} delete pod $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::forceDeletePod() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} delete pod $pod --force --grace-period=0
  xtrace off
}

function kubectl::showLogs() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogsNoTimeout() {
  pod=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod --timeout=1s
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod
  xtrace off
  checkInteractiveMode
}

function kubectl::showLogsByContainer() {
  pod=$1
  container=$2
  shift
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} wait --for=condition=ready pod $pod
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} logs $pod -c $container
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainer() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $*
  xtrace off
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithReturnCarriage() {
  pod=$1
  shift
  xtrace on
  kubectl exec $pod -- $*
  xtrace off
  echo
  checkInteractiveMode
}

function kubectl::execUniqueContainerWithTty() {
  pod=$1
  shift
  xtrace on
  kubectl exec -it $pod -- $@
  xtrace off
  checkInteractiveMode
}

function kubectl::execContainer() {
  pod=$1
  container=$2
  shift
  shift
  xtrace on
  kubectl exec $pod -c $container -- $*
  xtrace off
  checkInteractiveMode
}

##########################
#   REPLICASET METHODS   #
##########################

function kubectl::showReplicaSets() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showReplicaSetsInAllNamespaces() {
  print_info "Show replicasets"
  kubectl::manageArguments $@
  xtrace on
  kubectl get rs --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromReplicaSet() {
  replicaSet=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get rs $replicaSet -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleReplicaSet() {
  replicaSet=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale replicaset $replicaSet --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

##########################
#   DEPLOYMENT METHODS   #
##########################

function kubectl::showDeployments() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  #kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS} -o wide
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get deploy ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showDeploymentsInAllNamespaces() {
  print_info "Show deployments"
  kubectl::manageArguments $@
  xtrace on
  kubectl get deploy --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::getReplicasFromDeployment() {
  deploy=$1
  kubectl::manageArguments $@
  shift
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get deploy $deploy -o jsonpath="{.spec.replicas}"
  xtrace off
}

function kubectl::scaleDeployment() {
  deploy=$1
  replicas=$2
  shift
  print_info "Scale replicas to $replicas"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    scale deployment $deploy --replicas=$replicas
  xtrace off
  checkInteractiveMode
}

function kubectl::waitForDeployment() {
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    wait --for=condition=available deployment $deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::showRolloutStatusFromDeployment() {
  print_info "Show rollout status from deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout status deployment $deploy
  xtrace off
  checkInteractiveMode
}

function kubectl::showRolloutHistoryFromDeployment() {
  print_info "Show rollout history from deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout history deployment $deploy
    # --revision=$2
  xtrace off
  checkInteractiveMode
}

function kubectl::annotateDeploymentChangeCause() {
  deploy=$1
  shift
  message=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    annotate deployment $deploy \
    kubernetes.io/change-cause="$message"
  xtrace off
  checkInteractiveMode
}

function kubectl::rollbackDeployment() {
  print_info "Rollout undo deployment"
  deploy=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    rollout undo deployment $deploy
    # --to-revision=$2
  xtrace off
  checkInteractiveMode
}

##########################
#     SERVICE METHODS    #
##########################

function kubectl::showServices() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showServicesInAllNamespaces() {
  print_info "Show services"
  kubectl::manageArguments $@
  xtrace on
  kubectl get svc --all-namespaces ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showEndpointsByService() {
  print_info "Show endpoints filtered by service"
  service=$1
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get endpoints $service
  xtrace off
  checkInteractiveMode
}

function kubectl::getPortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].port"
  xtrace off
}

function kubectl::getNodePortByService() {
  service=$1
  targetPort=$2
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get svc $service --no-headers \
    -o custom-columns=":spec.ports[?(@.targetPort == '$targetPort')].nodePort"
  xtrace off
}

##########################
#   PERSISTENT VOLUMES   #
##########################

function kubectl::showPersistentVolumes() {
  xtrace on
  kubectl get pv ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showPersistentVolumeClaims() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get pvc ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

##########################
#   CONFIGMAP METHODS    #
##########################

function kubectl::showConfigMaps() {
  print_info "Show configmaps"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get cm ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showConfigMapDescription() {
  configmap=$1
  shift
  print_info "Show configmap description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe cm $configmap ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

##########################
#    SECRETS METHODS     #
##########################

function kubectl::createGenericSecret() {
  dstFile=$1
  shift
  secret=$1
  shift
  pocLabel=$1
  shift
  print_info "Create generic secret and edit labels"
  xtrace on
  kubectl create secret generic $secret $@ \
    --dry-run=client -o yaml | \
    sed -e 's|creationTimestamp: null|labels:|' | \
    sed -e "s/labels:/& \n    $pocLabel/" | \
    tee $dstFile | kubectl apply -f -
  xtrace off
  checkInteractiveMode
}

function kubectl::showSecrets() {
  print_info "Show secrets"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get secrets ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showSecretDescription() {
  secret=$1
  shift
  print_info "Show secret description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe secrets $secret ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::decodeSecretByKey() {
  secret=$1
  secretKey=$2
  shift
  shift
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get secret $secret \
    -o custom-columns=":data['${secretKey}']" | base64 --decode
  xtrace off
}

function kubectl::deleteSecret() {
  xtrace on
  kubectl delete secret $1
  xtrace off
  checkInteractiveMode
}

##########################
#      RBAC METHODS      #
##########################

function kubectl::showRoles() {
  print_info "Show roles"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get roles ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showRoleDescription() {
  role=$1
  shift
  print_info "Show role description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe role $role ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showRoleBindings() {
  print_info "Show rolebindings"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get rolebindings ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showRoleBindingDescription() {
  role=$1
  shift
  print_info "Show rolebinding description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe rolebinding $role ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showClusterRoles() {
  print_info "Show cluster roles"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get clusterroles ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showClusterRoleDescription() {
  role=$1
  shift
  print_info "Show clusterrole description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe clusterrole $role ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showClusterRoleBindings() {
  print_info "Show rolebindings"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    get clusterrolebindings ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

function kubectl::showClusterRoleBindingDescription() {
  role=$1
  shift
  print_info "Show rolebinding description"
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    describe clusterrolebinding $role ${LABELS:+-l $LABELS}
  xtrace off
  checkInteractiveMode
}

###################################
#    HORIZONTAL POD AUTOSCALER    #
###################################

function kubectl::getHorizontalPodAutoscaler() {
  kubectl::manageArguments $@
  xtrace on
  kubectl ${NAMESPACE:+--namespace $NAMESPACE} get hpa ${LABELS:+-l $LABELS}
  xtrace off
}

##########################
#     METRICS SERVER     #
##########################

function kubectl::resetMetricsServer() {
  print_debug "Reset metrics server to clean obsolete pod data"
  PODS=($(kubectl::getRunningPods -n kube-system | grep ^metrics-server))
  for pod in $PODS; do
    kubectl::forceDeletePod $pod -n kube-system
  done
  checkInteractiveMode
}

function kubectl::checkNodeMetrics() {
  isTraceEnabled=${1:-false}
  if [ $isTraceEnabled = true ]; then
      xtrace on
  fi

  kubectl top nodes 2> /dev/null

  result=$?
  xtrace off
  return $result
}

function kubectl::waitForNodeMetrics() {
  print_debug "Waiting for available node metrics..."
  kubectl::checkNodeMetrics true
  local areMetricsAvailable=$?
  local endTime=$(( $(date +%s) + $METRICS_TIMEOUT_SECS )) # Calculate end time.
  while [ $areMetricsAvailable != 0 -a $(date +%s) -lt $endTime ]; do  # Loop until interval has elapsed.
    sleep $METRICS_INTERVAL_SECS
    kubectl::checkNodeMetrics
    areMetricsAvailable=$?
  done

  if [ $areMetricsAvailable -ne 0 ]; then
    print_warn "Timeout. Metrics server unavailable"
  fi

  return $areMetricsAvailable
}

function kubectl::showNodeMetrics() {
  kubectl::waitForNodeMetrics &
  PID=$!
  showProgressBar $PID
  wait $PID
}

function kubectl::checkPodMetrics() {
  isTraceEnabled=$1
  shift
  if [ $isTraceEnabled = true ]; then
      xtrace on
  fi

  kubectl ${NAMESPACE:+--namespace $NAMESPACE} \
    top pods ${LABELS:+-l $LABELS} --containers 2> /dev/null

  result=$?
  xtrace off
  return $result
}

function kubectl::waitForPodMetrics() {
  print_debug "Waiting for available pod metrics..."
  kubectl::manageArguments $@
  kubectl::checkPodMetrics true $@
  local areMetricsAvailable=$?
  local endTime=$(( $(date +%s) + $METRICS_TIMEOUT_SECS )) # Calculate end time.
  while [ $areMetricsAvailable != 0 -a $(date +%s) -lt $endTime ]; do  # Loop until interval has elapsed.
    sleep $METRICS_INTERVAL_SECS
    kubectl::checkPodMetrics false $@
    areMetricsAvailable=$?
  done

  if [ $areMetricsAvailable -ne 0 ]; then
    print_warn "Timeout. Metrics server unavailable"
  fi

  return $areMetricsAvailable
}


function kubectl::showPodMetrics() {
  kubectl::waitForPodMetrics &
  PID=$!
  showProgressBar $PID
  wait $PID
}

function kubectl::waitForPodMetricsUntilPodRestarted() {
  declare -i isRestarted=0
  previousRestartCount=$(kubectl::getRestartCountByPod $1)
  previousRestartCount=${previousRestartCount:-0}
  local endTime=$(( $(date +%s) + $RESTART_TIMEOUT_SECS )) # Calculate end time.
  while [ $isRestarted -eq 0 -a $(date +%s) -lt $endTime ]; do  # Loop until interval has elapsed.
    kubectl::waitForPodMetrics
    sleep $RESTART_INTERVAL_SECS
    currentRestartCount=$(kubectl::getRestartCountByPod $1)
    currentRestartCount=${currentRestartCount:-0}
    if [ $currentRestartCount -gt $previousRestartCount ];then
      isRestarted=1
    fi
  done

  return $isRestarted
}

function kubectl::watchPodMetricsUntilPodRestarted() {
  kubectl::waitForPodMetricsUntilPodRestarted $1 &
  PID=$!
  showProgressBar $PID
  wait $PID
}

function kubectl::waitForPodRestarted() {
  declare -i isRestarted=0
  previousRestartCount=$(kubectl::getRestartCountByPod $1)
  previousRestartCount=${previousRestartCount:-0}
  local endTime=$(( $(date +%s) + $RESTART_TIMEOUT_SECS )) # Calculate end time.
  while [ $isRestarted -eq 0 -a $(date +%s) -lt $endTime ]; do  # Loop until interval has elapsed.
    sleep $RESTART_INTERVAL_SECS
    currentRestartCount=$(kubectl::getRestartCountByPod $1)
    currentRestartCount=${currentRestartCount:-0}
    if [ $currentRestartCount -gt $previousRestartCount ];then
      isRestarted=1
    fi
  done

  return $isRestarted
}
